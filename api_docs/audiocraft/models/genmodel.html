<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>audiocraft.models.genmodel API documentation</title>
<meta name="description" content="Base implementation for audio generative models. This base implementation
combines all the required components to run inference with pretrained audio
…">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>audiocraft.models.genmodel</code></h1>
</header>
<section id="section-intro">
<p>Base implementation for audio generative models. This base implementation
combines all the required components to run inference with pretrained audio
generative models. It can be easily inherited by downstream model classes to
provide easy access to the generation API.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel"><code class="flex name class">
<span>class <span class="ident">BaseGenModel</span></span>
<span>(</span><span>name: str,<br>compression_model: <a title="audiocraft.models.encodec.CompressionModel" href="encodec.html#audiocraft.models.encodec.CompressionModel">CompressionModel</a>,<br>lm: <a title="audiocraft.models.lm.LMModel" href="lm.html#audiocraft.models.lm.LMModel">LMModel</a>,<br>max_duration: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseGenModel(ABC):
    &#34;&#34;&#34;Base generative model with convenient generation API.

    Args:
        name (str): name of the model.
        compression_model (CompressionModel): Compression model
            used to map audio to invertible discrete representations.
        lm (LMModel): Language model over discrete representations.
        max_duration (float, optional): maximum duration the model can produce,
            otherwise, inferred from the training params.
    &#34;&#34;&#34;
    def __init__(self, name: str, compression_model: CompressionModel, lm: LMModel,
                 max_duration: tp.Optional[float] = None):
        self.name = name
        self.compression_model = compression_model
        self.lm = lm
        self.cfg: tp.Optional[omegaconf.DictConfig] = None
        # Just to be safe, let&#39;s put everything in eval mode.
        self.compression_model.eval()
        self.lm.eval()

        if hasattr(lm, &#39;cfg&#39;):
            cfg = lm.cfg
            assert isinstance(cfg, omegaconf.DictConfig)
            self.cfg = cfg

        if self.cfg is not None:
            self.compression_model = get_wrapped_compression_model(self.compression_model, self.cfg)

        if max_duration is None:
            if self.cfg is not None:
                max_duration = lm.cfg.dataset.segment_duration  # type: ignore
            else:
                raise ValueError(&#34;You must provide max_duration when building directly your GenModel&#34;)
        assert max_duration is not None

        self.max_duration: float = max_duration
        self.duration = self.max_duration

        # self.extend_stride is the length of audio extension when generating samples longer
        # than self.max_duration. NOTE: the derived class must set self.extend_stride to a
        # positive float value when generating with self.duration &gt; self.max_duration.
        self.extend_stride: tp.Optional[float] = None
        self.device = next(iter(lm.parameters())).device
        self.generation_params: dict = {}
        self._progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None
        if self.device.type == &#39;cpu&#39;:
            self.autocast = TorchAutocast(enabled=False)
        else:
            self.autocast = TorchAutocast(
                enabled=True, device_type=self.device.type, dtype=torch.float16)

    @property
    def frame_rate(self) -&gt; float:
        &#34;&#34;&#34;Roughly the number of AR steps per seconds.&#34;&#34;&#34;
        return self.compression_model.frame_rate

    @property
    def sample_rate(self) -&gt; int:
        &#34;&#34;&#34;Sample rate of the generated audio.&#34;&#34;&#34;
        return self.compression_model.sample_rate

    @property
    def audio_channels(self) -&gt; int:
        &#34;&#34;&#34;Audio channels of the generated audio.&#34;&#34;&#34;
        return self.compression_model.channels

    def set_custom_progress_callback(self, progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None):
        &#34;&#34;&#34;Override the default progress callback.&#34;&#34;&#34;
        self._progress_callback = progress_callback

    @abstractmethod
    def set_generation_params(self, *args, **kwargs):
        &#34;&#34;&#34;Set the generation parameters.&#34;&#34;&#34;
        raise NotImplementedError(&#34;No base implementation for setting generation params.&#34;)

    @staticmethod
    @abstractmethod
    def get_pretrained(name: str, device=None):
        raise NotImplementedError(&#34;No base implementation for getting pretrained model&#34;)

    @torch.no_grad()
    def _prepare_tokens_and_attributes(
            self,
            descriptions: tp.Sequence[tp.Optional[str]],
            prompt: tp.Optional[torch.Tensor],
    ) -&gt; tp.Tuple[tp.List[ConditioningAttributes], tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;Prepare model inputs.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            prompt (torch.Tensor): A batch of waveforms used for continuation.
        &#34;&#34;&#34;
        attributes = [
            ConditioningAttributes(text={&#39;description&#39;: description})
            for description in descriptions]

        if prompt is not None:
            if descriptions is not None:
                assert len(descriptions) == len(prompt), &#34;Prompt and nb. descriptions doesn&#39;t match&#34;
            prompt = prompt.to(self.device)
            prompt_tokens, scale = self.compression_model.encode(prompt)
            assert scale is None
        else:
            prompt_tokens = None
        return attributes, prompt_tokens

    def generate_unconditional(self, num_samples: int, progress: bool = False,
                               return_tokens: bool = False) -&gt; tp.Union[torch.Tensor,
                                                                        tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples in an unconditional manner.

        Args:
            num_samples (int): Number of samples to be generated.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        descriptions: tp.List[tp.Optional[str]] = [None] * num_samples
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate(self, descriptions: tp.List[str], progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on text.

        Args:
            descriptions (list of str): A list of strings used as text conditioning.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
        assert prompt_tokens is None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def generate_continuation(self, prompt: torch.Tensor, prompt_sample_rate: int,
                              descriptions: tp.Optional[tp.List[tp.Optional[str]]] = None,
                              progress: bool = False, return_tokens: bool = False) \
            -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
        &#34;&#34;&#34;Generate samples conditioned on audio prompts and an optional text description.

        Args:
            prompt (torch.Tensor): A batch of waveforms used for continuation.
                Prompt should be [B, C, T], or [C, T] if only one sample is generated.
            prompt_sample_rate (int): Sampling rate of the given audio waveforms.
            descriptions (list of str, optional): A list of strings used as text conditioning. Defaults to None.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        &#34;&#34;&#34;
        if prompt.dim() == 2:
            prompt = prompt[None]
        if prompt.dim() != 3:
            raise ValueError(&#34;prompt should have 3 dimensions: [B, C, T] (C = 1).&#34;)
        prompt = convert_audio(prompt, prompt_sample_rate, self.sample_rate, self.audio_channels)
        if descriptions is None:
            descriptions = [None] * len(prompt)
        attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, prompt)
        assert prompt_tokens is not None
        tokens = self._generate_tokens(attributes, prompt_tokens, progress)
        if return_tokens:
            return self.generate_audio(tokens), tokens
        return self.generate_audio(tokens)

    def _generate_tokens(self, attributes: tp.List[ConditioningAttributes],
                         prompt_tokens: tp.Optional[torch.Tensor], progress: bool = False) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate discrete audio tokens given audio prompt and/or conditions.

        Args:
            attributes (list of ConditioningAttributes): Conditions used for generation (here text).
            prompt_tokens (torch.Tensor, optional): Audio prompt used for continuation.
            progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
        Returns:
            torch.Tensor: Generated audio, of shape [B, C, T], T is defined by the generation params.
        &#34;&#34;&#34;
        total_gen_len = int(self.duration * self.frame_rate)
        max_prompt_len = int(min(self.duration, self.max_duration) * self.frame_rate)
        current_gen_offset: int = 0

        def _progress_callback(generated_tokens: int, tokens_to_generate: int):
            generated_tokens += current_gen_offset
            if self._progress_callback is not None:
                # Note that total_gen_len might be quite wrong depending on the
                # codebook pattern used, but with delay it is almost accurate.
                self._progress_callback(generated_tokens, tokens_to_generate)
            else:
                print(f&#39;{generated_tokens: 6d} / {tokens_to_generate: 6d}&#39;, end=&#39;\r&#39;)

        if prompt_tokens is not None:
            assert max_prompt_len &gt;= prompt_tokens.shape[-1], \
                &#34;Prompt is longer than audio to generate&#34;

        callback = None
        if progress:
            callback = _progress_callback

        if self.duration &lt;= self.max_duration:
            # generate by sampling from LM, simple case.
            with self.autocast:
                gen_tokens = self.lm.generate(
                    prompt_tokens, attributes,
                    callback=callback, max_gen_len=total_gen_len, **self.generation_params)

        else:
            assert self.extend_stride is not None, &#34;Stride should be defined to generate beyond max_duration&#34;
            assert self.extend_stride &lt; self.max_duration, &#34;Cannot stride by more than max generation duration.&#34;
            all_tokens = []
            if prompt_tokens is None:
                prompt_length = 0
            else:
                all_tokens.append(prompt_tokens)
                prompt_length = prompt_tokens.shape[-1]

            stride_tokens = int(self.frame_rate * self.extend_stride)
            while current_gen_offset + prompt_length &lt; total_gen_len:
                time_offset = current_gen_offset / self.frame_rate
                chunk_duration = min(self.duration - time_offset, self.max_duration)
                max_gen_len = int(chunk_duration * self.frame_rate)
                with self.autocast:
                    gen_tokens = self.lm.generate(
                        prompt_tokens, attributes,
                        callback=callback, max_gen_len=max_gen_len, **self.generation_params)
                if prompt_tokens is None:
                    all_tokens.append(gen_tokens)
                else:
                    all_tokens.append(gen_tokens[:, :, prompt_tokens.shape[-1]:])
                prompt_tokens = gen_tokens[:, :, stride_tokens:]
                prompt_length = prompt_tokens.shape[-1]
                current_gen_offset += stride_tokens

            gen_tokens = torch.cat(all_tokens, dim=-1)
        return gen_tokens

    def generate_audio(self, gen_tokens: torch.Tensor) -&gt; torch.Tensor:
        &#34;&#34;&#34;Generate Audio from tokens.&#34;&#34;&#34;
        assert gen_tokens.dim() == 3
        with torch.no_grad():
            gen_audio = self.compression_model.decode(gen_tokens, None)
        return gen_audio</code></pre>
</details>
<div class="desc"><p>Base generative model with convenient generation API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the model.</dd>
<dt><strong><code>compression_model</code></strong> :&ensp;<code>CompressionModel</code></dt>
<dd>Compression model
used to map audio to invertible discrete representations.</dd>
<dt><strong><code>lm</code></strong> :&ensp;<code>LMModel</code></dt>
<dd>Language model over discrete representations.</dd>
<dt><strong><code>max_duration</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>maximum duration the model can produce,
otherwise, inferred from the training params.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="audiocraft.models.audiogen.AudioGen" href="audiogen.html#audiocraft.models.audiogen.AudioGen">AudioGen</a></li>
<li><a title="audiocraft.models.jasco.JASCO" href="jasco.html#audiocraft.models.jasco.JASCO">JASCO</a></li>
<li><a title="audiocraft.models.magnet.MAGNeT" href="magnet.html#audiocraft.models.magnet.MAGNeT">MAGNeT</a></li>
<li><a title="audiocraft.models.musicgen.MusicGen" href="musicgen.html#audiocraft.models.musicgen.MusicGen">MusicGen</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.get_pretrained"><code class="name flex">
<span>def <span class="ident">get_pretrained</span></span>(<span>name: str, device=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def get_pretrained(name: str, device=None):
    raise NotImplementedError(&#34;No base implementation for getting pretrained model&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.audio_channels"><code class="name">prop <span class="ident">audio_channels</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def audio_channels(self) -&gt; int:
    &#34;&#34;&#34;Audio channels of the generated audio.&#34;&#34;&#34;
    return self.compression_model.channels</code></pre>
</details>
<div class="desc"><p>Audio channels of the generated audio.</p></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.frame_rate"><code class="name">prop <span class="ident">frame_rate</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_rate(self) -&gt; float:
    &#34;&#34;&#34;Roughly the number of AR steps per seconds.&#34;&#34;&#34;
    return self.compression_model.frame_rate</code></pre>
</details>
<div class="desc"><p>Roughly the number of AR steps per seconds.</p></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.sample_rate"><code class="name">prop <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self) -&gt; int:
    &#34;&#34;&#34;Sample rate of the generated audio.&#34;&#34;&#34;
    return self.compression_model.sample_rate</code></pre>
</details>
<div class="desc"><p>Sample rate of the generated audio.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self,<br>descriptions: List[str],<br>progress: bool = False,<br>return_tokens: bool = False) ‑> torch.Tensor | Tuple[torch.Tensor, torch.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, descriptions: tp.List[str], progress: bool = False, return_tokens: bool = False) \
        -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples conditioned on text.

    Args:
        descriptions (list of str): A list of strings used as text conditioning.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
    assert prompt_tokens is None
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
<div class="desc"><p>Generate samples conditioned on text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>descriptions</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings used as text conditioning.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_audio"><code class="name flex">
<span>def <span class="ident">generate_audio</span></span>(<span>self, gen_tokens: torch.Tensor) ‑> torch.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_audio(self, gen_tokens: torch.Tensor) -&gt; torch.Tensor:
    &#34;&#34;&#34;Generate Audio from tokens.&#34;&#34;&#34;
    assert gen_tokens.dim() == 3
    with torch.no_grad():
        gen_audio = self.compression_model.decode(gen_tokens, None)
    return gen_audio</code></pre>
</details>
<div class="desc"><p>Generate Audio from tokens.</p></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_continuation"><code class="name flex">
<span>def <span class="ident">generate_continuation</span></span>(<span>self,<br>prompt: torch.Tensor,<br>prompt_sample_rate: int,<br>descriptions: List[str | None] | None = None,<br>progress: bool = False,<br>return_tokens: bool = False) ‑> torch.Tensor | Tuple[torch.Tensor, torch.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_continuation(self, prompt: torch.Tensor, prompt_sample_rate: int,
                          descriptions: tp.Optional[tp.List[tp.Optional[str]]] = None,
                          progress: bool = False, return_tokens: bool = False) \
        -&gt; tp.Union[torch.Tensor, tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples conditioned on audio prompts and an optional text description.

    Args:
        prompt (torch.Tensor): A batch of waveforms used for continuation.
            Prompt should be [B, C, T], or [C, T] if only one sample is generated.
        prompt_sample_rate (int): Sampling rate of the given audio waveforms.
        descriptions (list of str, optional): A list of strings used as text conditioning. Defaults to None.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    if prompt.dim() == 2:
        prompt = prompt[None]
    if prompt.dim() != 3:
        raise ValueError(&#34;prompt should have 3 dimensions: [B, C, T] (C = 1).&#34;)
    prompt = convert_audio(prompt, prompt_sample_rate, self.sample_rate, self.audio_channels)
    if descriptions is None:
        descriptions = [None] * len(prompt)
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, prompt)
    assert prompt_tokens is not None
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
<div class="desc"><p>Generate samples conditioned on audio prompts and an optional text description.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>A batch of waveforms used for continuation.
Prompt should be [B, C, T], or [C, T] if only one sample is generated.</dd>
<dt><strong><code>prompt_sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Sampling rate of the given audio waveforms.</dd>
<dt><strong><code>descriptions</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of strings used as text conditioning. Defaults to None.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.generate_unconditional"><code class="name flex">
<span>def <span class="ident">generate_unconditional</span></span>(<span>self, num_samples: int, progress: bool = False, return_tokens: bool = False) ‑> torch.Tensor | Tuple[torch.Tensor, torch.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_unconditional(self, num_samples: int, progress: bool = False,
                           return_tokens: bool = False) -&gt; tp.Union[torch.Tensor,
                                                                    tp.Tuple[torch.Tensor, torch.Tensor]]:
    &#34;&#34;&#34;Generate samples in an unconditional manner.

    Args:
        num_samples (int): Number of samples to be generated.
        progress (bool, optional): Flag to display progress of the generation process. Defaults to False.
    &#34;&#34;&#34;
    descriptions: tp.List[tp.Optional[str]] = [None] * num_samples
    attributes, prompt_tokens = self._prepare_tokens_and_attributes(descriptions, None)
    tokens = self._generate_tokens(attributes, prompt_tokens, progress)
    if return_tokens:
        return self.generate_audio(tokens), tokens
    return self.generate_audio(tokens)</code></pre>
</details>
<div class="desc"><p>Generate samples in an unconditional manner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples to be generated.</dd>
<dt><strong><code>progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to display progress of the generation process. Defaults to False.</dd>
</dl></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback"><code class="name flex">
<span>def <span class="ident">set_custom_progress_callback</span></span>(<span>self, progress_callback: Callable[[int, int], None] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_progress_callback(self, progress_callback: tp.Optional[tp.Callable[[int, int], None]] = None):
    &#34;&#34;&#34;Override the default progress callback.&#34;&#34;&#34;
    self._progress_callback = progress_callback</code></pre>
</details>
<div class="desc"><p>Override the default progress callback.</p></div>
</dd>
<dt id="audiocraft.models.genmodel.BaseGenModel.set_generation_params"><code class="name flex">
<span>def <span class="ident">set_generation_params</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def set_generation_params(self, *args, **kwargs):
    &#34;&#34;&#34;Set the generation parameters.&#34;&#34;&#34;
    raise NotImplementedError(&#34;No base implementation for setting generation params.&#34;)</code></pre>
</details>
<div class="desc"><p>Set the generation parameters.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="audiocraft.models" href="index.html">audiocraft.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="audiocraft.models.genmodel.BaseGenModel" href="#audiocraft.models.genmodel.BaseGenModel">BaseGenModel</a></code></h4>
<ul class="">
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.audio_channels" href="#audiocraft.models.genmodel.BaseGenModel.audio_channels">audio_channels</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.frame_rate" href="#audiocraft.models.genmodel.BaseGenModel.frame_rate">frame_rate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate" href="#audiocraft.models.genmodel.BaseGenModel.generate">generate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_audio" href="#audiocraft.models.genmodel.BaseGenModel.generate_audio">generate_audio</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_continuation" href="#audiocraft.models.genmodel.BaseGenModel.generate_continuation">generate_continuation</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.generate_unconditional" href="#audiocraft.models.genmodel.BaseGenModel.generate_unconditional">generate_unconditional</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.get_pretrained" href="#audiocraft.models.genmodel.BaseGenModel.get_pretrained">get_pretrained</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.sample_rate" href="#audiocraft.models.genmodel.BaseGenModel.sample_rate">sample_rate</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback" href="#audiocraft.models.genmodel.BaseGenModel.set_custom_progress_callback">set_custom_progress_callback</a></code></li>
<li><code><a title="audiocraft.models.genmodel.BaseGenModel.set_generation_params" href="#audiocraft.models.genmodel.BaseGenModel.set_generation_params">set_generation_params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
